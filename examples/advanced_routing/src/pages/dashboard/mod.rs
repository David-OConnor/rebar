use seed::{prelude::*, *};
pub mod message;
pub mod statistics;
pub mod tasks;
use crate::pages::dashboard::tasks::TasksRoutes;
use crate::router;
pub use router::Init;
pub use router::View;
use seed_routing::*;

#[derive(Debug, PartialEq, Clone, RoutingModules)]
pub enum DashboardRoutes {
    Message,
    Tasks {
        query: IndexMap<String, String>,
        children: TasksRoutes,
    },
    Statistics,
    #[default_route]
    #[view = "=> root"]
    #[as_path = ""]
    Root,
}
pub fn init(
    _: Url,
    model: &mut Model,
    nested: &DashboardRoutes,
    orders: &mut impl Orders<Msg>,
) -> Model {
    nested.init(model, orders);
    model.clone()
}

#[derive(Default, Clone)]
pub struct Model {
    pub name: String,
    pub message: message::Model,
    pub statistics: statistics::Model,
    pub tasks: tasks::Model,
}

pub enum Msg {
    ChangeName,
    Message(message::Msg),
    Statistics(statistics::Msg),
    Tasks(tasks::Msg),
}

// todo could be generated by derive macro as well
pub fn update(msg: Msg, model: &mut Model, orders: &mut impl Orders<Msg>) {
    match msg {
        Msg::ChangeName => {}
        Msg::Message(message) => {
            message::update(message, &mut model.message, &mut orders.proxy(Msg::Message))
        }
        Msg::Statistics(statistics) => statistics::update(
            statistics,
            &mut model.statistics,
            &mut orders.proxy(Msg::Statistics),
        ),
        Msg::Tasks(task) => tasks::update(task, &mut model.tasks, &mut orders.proxy(Msg::Tasks)),
    }
}
pub fn view(dashboard_routes: &DashboardRoutes, model: &Model) -> Node<Msg> {
    dashboard_routes.view(model)
}

pub fn root(_: &Model) -> Node<Msg> {
    div!["root for dashboard"]
}
